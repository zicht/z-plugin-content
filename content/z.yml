# @version ">=2.0"

# Content options
content:
    # Dirs that contain user content (i.e. uploaded files and such)
    dir:            [ 'web/media' ]
    exclude:        [ "cache" ]

tasks:
    content.files.pull:
        help: |
            Sync remote with local content folder.

            Use the content.dir to define the folder to sync and
            content.exlude for exlusion of folder within that folder.

            The --rsync-flags flag can be used to overwrite the rsync flags, so for example:

            z content:files:pull --rsync-flags="-ru --delete --inplace" production

            will genertae something like:

            rsync -ru --delete --inplace example@example.com:/home/example/web/media/ ./web/media/
        args:
            target_env: ?
        opts:
            rsync_flags:
        flags:
            simulate: false
            delete: false
        do: |
            @(for d in content.dir)
                $(content.fmt.cmd.rsync(fmt.path(sprintf("%s:%s", envs[target_env].ssh, envs[target_env].root), d),fmt.path(envs.local.root, d)))

    content.files.push:
        help: |
            Sync local with remote content folder.

            Use the content.dir to define the folder to sync and
            content.exlude for exlusion of folder within that folder.

            The --rsync-flags flag can be used to overwrite the rsync flags, so for example:

            z content:files:push --rsync-flags="-ru --delete --inplace" production

            will genertae something like:

            rsync -ru --delete --inplace ./web/media/ example@example.com:/home/example/web/media/
        args:
            target_env: ?
        opts:
            rsync_flags:
        flags:
            simulate: false
            delete: false
        do: |
            @(for d in content.dir)
                $(content.fmt.cmd.rsync(fmt.path(envs.local.root, d), fmt.path(sprintf("%s:%s", envs[target_env].ssh, envs[target_env].root), d)))

    content.db.pull:
        help: |
            Pull remote database/table to local database/table.

            If flag <info>no-drop</info> is given, the database won`t be dropped. Otherwise the local database will be dropped and recreated (unless the table or where flag is provided).

            To do a dump from remote to a local file this command can be executed the stdout flag:

                <info>z content:db:pull production --no-drop  -o | gzip -c > $(date +%Y%m%d).production.sql.gz</info>

            To us custom credentials/options for mysql(dump) see the defaults-local and defaults-remote options and:

                https://dev.mysql.com/doc/refman/5.7/en/option-files.html


        # will ad following flags by plugin.
        flags:
            drop: true
            local: false
            stdout: false
            # will ad following flags by plugin.
        opts:
            table: false
            where: false
            database: envs.local.db
            defaults_local: if_exist("./etc/mysql/.local.cnf")
            defaults_remote: false
        args:
            target_env: ?
        do:
            - @(if drop && !table && !where) mysql $(defaults_local ? sprintf("--defaults-file=%s", defaults_local)) -e "DROP DATABASE IF EXISTS $(database); CREATE DATABASE $(database);"
            - @(if !stdout) $(!content.is_local() ? content.fmt.ssh.prefix(target_env))mysqldump $(content.fmt.defaults.remote) --opt -Q$(VERBOSE ? "v") $(where ? sprintf("--where='%s'", where)) $(envs[target_env].db) $(table ? table) $(!content.is_local() ? content.fmt.ssh.suffix(target_env)) | mysql $(defaults_local ? sprintf("--defaults-file=%s", defaults_local)) $(database)
            - @(if stdout)  $(!content.is_local() ? content.fmt.ssh.prefix(target_env))mysqldump $(content.fmt.defaults.remote) --opt -Q$(VERBOSE ? "v") $(where ? sprintf("--where='%s'", where)) $(envs[target_env].db) $(table ? table) $(!content.is_local() ? content.fmt.ssh.suffix(target_env))

    content.db.push:
        help: |
            Push mysql dump file to remote database/table.

            to push from a backupfile, use the --file option

        flags:
            backup: true
            local: false
        opts:
            table: false
            where: false
            database: envs.local.db
            defaults_local: if_exist("./etc/mysql/.local.cnf")
            defaults_remote: false
            file: false
        args:
            target_env: ?

        do:
            - @(if backup && !table) $(z.cmd) content:db:pull $(target_env) --stdout --no-drop $(where ? sprintf("--where='%s'", where)) | gzip -c > $$(date +%Y%m%d)$(where ? sprintf(".%s", sha1(where))).$(target_env).sql.gz
            - @(if backup && table) @(for d in table) echo $(table) $(z.cmd) content:db:pull $(target_env) --stdout --no-drop $(where ? sprintf("--where='%s'", where)) --table="$(d)" | gzip -c > $$(date +%Y%m%d).$(d).$(target_env).sql.gz
            - @(if file)  cat $(file) | $(!content.is_local() ? content.fmt.ssh.prefix(target_env))mysql $(content.fmt.defaults.remote) --opt -Q$(VERBOSE ? "v") $(envs[target_env].db) $(!content.is_local() ? content.fmt.ssh.suffix(target_env))
            - @(if !file) mysqldump $(defaults_local ? sprintf("--defaults-file=%s", defaults_local)) $(where ? sprintf("--where='%s'", where)) $(database) $(table ? table) | $(!content.is_local() ? content.fmt.ssh.prefix(target_env))mysql $(content.fmt.defaults.remote) --opt -Q$(VERBOSE ? "v") $(envs[target_env].db)$(!content.is_local() ? content.fmt.ssh.suffix(target_env))

    content.db.backup:
        args:
            target_env: ?
        flags:
            local: false
        do:
            - $(z.cmd) content:db:pull $(target_env) --stdout $(local ? "--local") --no-drop | gzip -c > $$(date +%Y%m%d).$(target_env).sql.gz