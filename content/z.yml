# @version ">=2.0"

# Content options
content:
    # Dirs that contain user content (i.e. uploaded files and such)
    dir:            [ 'web/media' ]
    exclude:        [ "cache" ]
    db:
        structure:  ""
        full:       ""

tasks:
    content.backup:
        help: |
            Backup remote content into a content archive.

            Provide --files if you want to include content directories.

            The content archive will contain a dump of the configured envs[target_env].db name,
            and all content files of the remote installation
        args:
            target_env: ?
        set:
            _backup_file: sprintf("content-%s-%s%s.tar.gz", target_env, now, files ? "-with-files")
        flags:
            files: false
        do:
            - |
                ssh $(envs[target_env].ssh) "                                                        \
                    cd $(envs[target_env].root);                                                     \
                    $(
                        content.db.structure || content.db.full
                        ? cat(
                            sprintf("mysqldump %s -Q --opt -d %s %s    >  db.sql;", envs[target_env].db_defaults_file, envs[target_env].db, str(content.db.structure)),
                            sprintf("mysqldump %s -Q --opt %s %s       >> db.sql;", envs[target_env].db_defaults_file, envs[target_env].db, str(content.db.full))
                        )
                        : sprintf("mysqldump %s -Q --opt %s > db.sql;", envs[target_env].db_defaults_file, envs[target_env].db)
                    ) \
                    tar zc$(VERBOSE ? "v")f $(_backup_file) $(files ? content.dir) db.sql;      \
                    rm db.sql                                                           \
                "
            - rsync $(VERBOSE ? "--progress") $(envs[target_env].ssh):$(envs[target_env].root)$(_backup_file) ./$(_backup_file)
            - ssh $(envs[target_env].ssh) "rm $(envs[target_env].root)$(_backup_file)"

        yield: _backup_file

    content.pull:
        help: |
            Pull a content archive from a remote env into the local installation.

            If flag <info>nodrop</info> is given, the database won't be dropped. Otherwise the local database will be dropped and recreated.
        args:
            target_env:  ?
            file: tasks.content.backup
        flags:
            files: false
            nodrop: false
        do:
            - @content.load
            - rm $(file)

    content.push:
        help: |
            Push a content archive to a remote environment.
            The content archive is typically built by a content:dump or content:backup command:

                z content:backup staging
                z content:push production ./content-staging-*.tar.gz
        unless: !confirm(sprintf("You are %spushing content archive <comment>%s</comment> to environment <comment>%s</comment>, are you sure?", drop ? "dropping and ", file, target_env))
        args:
            target_env:  ?
            file: ?
        flags:
            drop: false
        do:
            - scp $(file) $(envs[target_env].ssh):$(envs[target_env].root)$(file)
            - @(if drop) ssh $(envs[target_env].ssh) "mysqladmin drop -f $(envs[target_env].db); mysqladmin create $(envs[target_env].db)"
            - ssh $(envs[target_env].ssh) "cd $(envs[target_env].root); tar zx$(VERBOSE ? "v")f $(file); mysql $(envs[target_env].db_defaults_file) $(envs[target_env].db) < ./db.sql; rm $(file); rm db.sql;"

    # Load a content archive
    content.load:
        help: |
            Load a content archive into the local environment.

            The local environment must be specified in your z.yml file as such:

                envs:
                    local: {db: "my_db_name", root: .}

            If flag <info>nodrop</info> is given, the database won't be dropped. Otherwise the local database will be dropped and recreated.
        args:
            file: ?
        flags:
            nodrop: false
        pre:
            - @(if !nodrop) @_content_clear_db
        do: |
            cd $(envs.local.root);
            tar zxvf $(file);
            mysql $(envs.local.db) < db.sql
            rm db.sql


    _content_clear_db:
        do:
            - echo "Dropping database <comment>$(envs.local.db)</comment>"
            - mysql -e "drop database if exists $(envs.local.db)"
            - echo "Creating database <comment>$(envs.local.db)</comment>"
            - mysql -e "create database $(envs.local.db)"

    content.download-files:
        help: |
            Download the content.dirs from the remote
        args:
            target_env: ?
        flags:
            simulate: false
            delete: false
            exclude_cache: true
        do: |
            @(for d in content.dir)
                rsync -ruv$(simulate ? "n") $(delete ? "--delete") $(exclude_cache ? "--exclude cache") $(envs[target_env].ssh):$(envs[target_env].root)$(d)/ $(envs.local.root)$(d)/

    content.upload-files:
        help: |
            Upload the content.dirs to the remote
        args:
            target_env: ?
        flags:
            simulate: false
            delete: false
            exclude_cache: true
        do: |
            @(for d in content.dir)
                rsync -ruv$(simulate ? "n") $(content.exclude_string) $(delete ? "--delete") $(exclude_cache ? "--exclude cache") $(envs.local.root)$(d)/ $(envs[target_env].ssh):$(envs[target_env].root)$(d)/

    content.db.push:
        help: |
            push local database/table to remote database/table
        flags:
            backup: true
        opts:
            table: false
            where: false
            local_user: false
            local_host: false
            local_port: false
            local_password: false
        args:
            target_env: ?
            local_db: ? false
        do:
            - @(if backup != false) ssh $(envs[target_env].ssh) "mysqldump -Q --opt $(content.sql_where)$(envs[target_env].db) $(table ? table)| gzip -c -9" > $(content.push_backup_file)
            - mysqldump $(content.local_db_args) $(table ? table) $(content.sql_where)| ssh $(envs[target_env].ssh) "mysql $(envs[target_env].db)"

    content.db.pull:
        help: |
            pull remote database/table to local database/file
        opts:
            table: false
            where: false
            local_user: false
            local_host: false
            local_port: false
            local_password: false
            file: false
        args:
            target_env: ?
            local_db: ? false
        do:
            - @(if file == false) ssh $(envs[target_env].ssh) "mysqldump -Q --opt $(content.sql_where)$(envs[target_env].db) $(table ? table)| gzip -c -9" | gzip -d - | mysql $(content.local_db_args)
            - @(if file != false) ssh $(envs[target_env].ssh) "mysqldump -Q --opt $(content.sql_where)$(envs[target_env].db) $(table ? table)| gzip -c -9" > $(file).tar.gz
